[
    {
        "content": "Refinery allows you to calculate new attributes to your already existing data. That means that you can write Python code that takes your existing record as input, does some transformations or uses outside APIs, and finally returns a value that is the value for this new attribute. The attribute calculation is applied to every record individually.\n\n## Motivation\n\nWe strongly believe that a good labeling environment has to be as flexible as possible in order to keep up with changing requirements. One of those tools enabling more flexibility is calculating new attributes while the project is already up and running. \n\nThis is useful for many scenarios, here are two examples:\n\n- You engineer the same features in many of your labeling functions so you decide to take the code and add it as a new attribute, which saves you a lot of computation in the weak supervision cycle.\n- While labeling you find that a useful predictor could be the sentiment of a given text. You decide to add a new attribute to your data that enriches your records with a sentiment score from a remote API that you know and trust.\n\nFor more inspiration, check out our content library called [bricks](https://bricks.kern.ai/home), where we collected commonly used NLP enrichments like profanity detection, E-Mail extraction, language translation, and many many more. They are all written in Python and designed to be copied into refinery directly.\n\n## Adding new attributes in refinery\n\nTo add a new attribute to your data, you have to visit the settings page and click the button \"add new attribute\" (see Fig.1).\n<CaptionedImage src=\"adding-attributes/adding_attributes_1.png\" title=\"Fig. 1: Screenshot of the settings page where the user is about to add a new attribute.\"/>\nAfter that, a modal will appear (see Fig. 2), which prompts you to input a new unique attribute name and the data type of that new attribute.\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_2.png\" title=\"Fig. 2: Screenshot of the modal that appears after clicking 'add new attribute'.\"/>\n\n<Note>\nOnly `text` attributes are available for tokenization and embedding creation.\n</Note>\n\nThe attribute data type acts as a safeguard for your calculated attribute because the calculation will throw an error when the returned value does not match the specified data type. Also, the data type will be considered in the data browser, so every data type has different filtering options. For example, an attribute of the boolean data type can only be toggled on or off during filtering, there are no additional options for it. If you want to know more about the effects of selecting the data types, please read the section about [attribute filters](/refinery/data-management#attribute-filters).\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_3.png\" title=\"Fig. 3: Screenshot of an attribute calculation function that adds a new attribute, which is a list of people that are referenced in the attribute 'headline'. Notice that this function has not been run yet and therefore displays the state 'Registered' next to its name at the top.\"/>\nAfter creating the function, we are greeted by the usual interface that you should be familiar with from the [labeling functions](/refinery/building-labeling-functions). The input that you get is still a single record, that can be treated as a dictionary, where every text attribute is of type `spaCy Doc` (see [their documentation](https://spacy.io/api/doc)). That is why we can iterate through the entities of the attribute \"headline\" that were extracted during the tokenization process.\n\n<Note>\nYou can use requests in your attribute calculation.\nWhen you want to enrich your records with an outside or local running API, then you can use the [requests Python package](https://pypi.org/project/requests/) in your attribute calculation function.\n</Note>\nAfter assembling your attribute in the function you just have to return it. Make sure that the data type matches the one you specified because otherwise you will get an error. Good practice is to use the \"run on 10\" feature before committing to the attribute calculation, as this will usually clear up any bugs.\n\nWhen everything is finalized and you tested your function, you can press on \"run\" in the bottom right corner. This will execute the attribute calculation function on your whole data. Please note that this calculated attribute is immutable after execution, so if you need to adjust something, you will need to create a new attribute and copy the old code.\n<CaptionedImage src=\"adding-attributes/adding_attributes_4.png\" title=\"Fig. 4: After execution, the new attribute is now immutable and in the state 'usable'.\"/>\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_5.png\" title=\"Fig. 5: A screenshot of a record in the data browser, where we can see the newly added attribute.\"/>"
    },
    {
        "content": "We strongly believe that a good labeling environment has to be as flexible as possible in order to keep up with changing requirements. One of those tools enabling more flexibility is calculating new attributes while the project is already up and running. \n\nThis is useful for many scenarios, here are two examples:\n\n- You engineer the same features in many of your labeling functions so you decide to take the code and add it as a new attribute, which saves you a lot of computation in the weak supervision cycle.\n- While labeling you find that a useful predictor could be the sentiment of a given text. You decide to add a new attribute to your data that enriches your records with a sentiment score from a remote API that you know and trust.\n\nFor more inspiration, check out our content library called [bricks](https://bricks.kern.ai/home), where we collected commonly used NLP enrichments like profanity detection, E-Mail extraction, language translation, and many many more. They are all written in Python and designed to be copied into refinery directly."
    },
    {
        "content": "To add a new attribute to your data, you have to visit the settings page and click the button \"add new attribute\" (see Fig.1).\n<CaptionedImage src=\"adding-attributes/adding_attributes_1.png\" title=\"Fig. 1: Screenshot of the settings page where the user is about to add a new attribute.\"/>\nAfter that, a modal will appear (see Fig. 2), which prompts you to input a new unique attribute name and the data type of that new attribute.\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_2.png\" title=\"Fig. 2: Screenshot of the modal that appears after clicking 'add new attribute'.\"/>\n\n<Note>\nOnly `text` attributes are available for tokenization and embedding creation.\n</Note>\n\nThe attribute data type acts as a safeguard for your calculated attribute because the calculation will throw an error when the returned value does not match the specified data type. Also, the data type will be considered in the data browser, so every data type has different filtering options. For example, an attribute of the boolean data type can only be toggled on or off during filtering, there are no additional options for it. If you want to know more about the effects of selecting the data types, please read the section about [attribute filters](/refinery/data-management#attribute-filters).\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_3.png\" title=\"Fig. 3: Screenshot of an attribute calculation function that adds a new attribute, which is a list of people that are referenced in the attribute 'headline'. Notice that this function has not been run yet and therefore displays the state 'Registered' next to its name at the top.\"/>\nAfter creating the function, we are greeted by the usual interface that you should be familiar with from the [labeling functions](/refinery/building-labeling-functions). The input that you get is still a single record, that can be treated as a dictionary, where every text attribute is of type `spaCy Doc` (see [their documentation](https://spacy.io/api/doc)). That is why we can iterate through the entities of the attribute \"headline\" that were extracted during the tokenization process.\n\n<Note>\nYou can use requests in your attribute calculation.\nWhen you want to enrich your records with an outside or local running API, then you can use the [requests Python package](https://pypi.org/project/requests/) in your attribute calculation function.\n</Note>\nAfter assembling your attribute in the function you just have to return it. Make sure that the data type matches the one you specified because otherwise you will get an error. Good practice is to use the \"run on 10\" feature before committing to the attribute calculation, as this will usually clear up any bugs.\n\nWhen everything is finalized and you tested your function, you can press on \"run\" in the bottom right corner. This will execute the attribute calculation function on your whole data. Please note that this calculated attribute is immutable after execution, so if you need to adjust something, you will need to create a new attribute and copy the old code.\n<CaptionedImage src=\"adding-attributes/adding_attributes_4.png\" title=\"Fig. 4: After execution, the new attribute is now immutable and in the state 'usable'.\"/>\n\n<CaptionedImage src=\"adding-attributes/adding_attributes_5.png\" title=\"Fig. 5: A screenshot of a record in the data browser, where we can see the newly added attribute.\"/>"
    },
    {
        "content": "Attribute visibility refers to the concept of hiding specific attributes that are not useful for the user to constantly see.\n<CaptionedImage src=\"/refinery/attribute-visibility/1.png\" title=\"Fig. 1: Screenshot of the settings page where the user can select the attribute visibility in a dropdown.\"/>\n## Visibility options\n\n`Do not hide`: This is the default option and has no effect on any display in refinery. The attribute is visible everywhere. Use this for attributes that are adding valuable information to your records that you want to see at all times.\n\n`Hide on data browser`: This option will hide the attribute only in the data browser, which means that you will not see the attribute in the record cards anymore. It also means that you will not be able to use attribute filters on that attribute. You could, however, define your data slices on an attribute, then hide it on the data browser, and your data slices will still work. This is best used for longer attributes that you don't want to clutter your data browser experience but are still informative during labeling.\n\n`Hide on labeling page`: This option will hide the attribute on both the data browser and labeling page. As these are the most interactive parts of the application, this is not that much different from hiding it completely. It will still appear on some other pages, e.g. in the \"run on 10\" feature of heuristics. This is best used for rather uninformative attributes that you don't need to be displayed at the moment, but are nice to see every once in a while in the application.\n\n`Hide`: This option will hide your attribute everywhere in refinery, where it does not negatively affect the user experience, e.g. it will still be visible in the \"copy attribute\" buttons of heuristics. Use this for attributes that you really don't need at the moment.\n<Note>\nChanging the visibility of an attribute is only temporary. You can always switch back to another visibility setting, so you can adapt this to the different requirements you might have at a certain point in your project.\n</Note>"
    },
    {
        "content": "`Do not hide`: This is the default option and has no effect on any display in refinery. The attribute is visible everywhere. Use this for attributes that are adding valuable information to your records that you want to see at all times.\n\n`Hide on data browser`: This option will hide the attribute only in the data browser, which means that you will not see the attribute in the record cards anymore. It also means that you will not be able to use attribute filters on that attribute. You could, however, define your data slices on an attribute, then hide it on the data browser, and your data slices will still work. This is best used for longer attributes that you don't want to clutter your data browser experience but are still informative during labeling.\n\n`Hide on labeling page`: This option will hide the attribute on both the data browser and labeling page. As these are the most interactive parts of the application, this is not that much different from hiding it completely. It will still appear on some other pages, e.g. in the \"run on 10\" feature of heuristics. This is best used for rather uninformative attributes that you don't need to be displayed at the moment, but are nice to see every once in a while in the application.\n\n`Hide`: This option will hide your attribute everywhere in refinery, where it does not negatively affect the user experience, e.g. it will still be visible in the \"copy attribute\" buttons of heuristics. Use this for attributes that you really don't need at the moment.\n<Note>\nChanging the visibility of an attribute is only temporary. You can always switch back to another visibility setting, so you can adapt this to the different requirements you might have at a certain point in your project.\n</Note>"
    }
]